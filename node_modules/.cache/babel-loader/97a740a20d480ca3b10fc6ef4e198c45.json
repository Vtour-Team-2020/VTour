{"ast":null,"code":"import AllLocations from \"./locationdata\";\nimport Location from \"./Location\";\nexport default class Map {\n  constructor() {\n    // init empty array\n    this.locationArray = [];\n    this.currentLocation = \"\";\n\n    for (var key in AllLocations) {\n      if (AllLocations.hasOwnProperty(key)) {\n        // construct location object\n        let newLocation = new Location(AllLocations[key]); // bind Entrance to newLocation\n\n        if (newLocation.name === \"Entrance\") {\n          this.currentLocation = newLocation;\n        }\n\n        this.locationArray.push(newLocation);\n      }\n    }\n  }\n\n  getCurrentLocation() {\n    return this.currentLocation;\n  }\n\n  getAllLocations() {\n    return this.locationArray;\n  }\n  /**\n   * returns the Location after a directino is issued. prints this in console \n   * @param {input direction} direction \n   */\n\n\n  move(direction) {\n    // find if there is neighbour\n    try {\n      let newLocationName = this.currentLocation.getNeighbourName(direction); // find the neighbour and set the current location to this location\n\n      var findResult = this.locationArray.find(function (element) {\n        return element.name === newLocationName;\n      });\n\n      if (findResult == undefined) {\n        throw \"Cannot find location\";\n      } else {\n        this.currentLocation = findResult;\n        console.log(\"User moves to this new location: \" + this.currentLocation.name);\n      }\n    } catch (err) {\n      console.log(\"User tries to move to a invalid location\");\n    }\n  }\n  /**\n   * logs all accessible neighbours\n   */\n\n\n  getAccesiblelocations() {\n    this.currentLocation.getAllNeighbours();\n    return;\n  }\n\n}","map":{"version":3,"sources":["/Users/bobby/Repositories/vtour/VTour-1/src/blogic/Map.js"],"names":["AllLocations","Location","Map","constructor","locationArray","currentLocation","key","hasOwnProperty","newLocation","name","push","getCurrentLocation","getAllLocations","move","direction","newLocationName","getNeighbourName","findResult","find","element","undefined","console","log","err","getAccesiblelocations","getAllNeighbours"],"mappings":"AAAA,OAAOA,YAAP,MAAyB,gBAAzB;AACA,OAAOC,QAAP,MAAqB,YAArB;AAEA,eAAe,MAAMC,GAAN,CAAU;AACrBC,EAAAA,WAAW,GAAE;AACT;AACA,SAAKC,aAAL,GAAqB,EAArB;AACA,SAAKC,eAAL,GAAuB,EAAvB;;AACA,SAAK,IAAIC,GAAT,IAAgBN,YAAhB,EAA6B;AAEzB,UAAIA,YAAY,CAACO,cAAb,CAA4BD,GAA5B,CAAJ,EAAqC;AAEjC;AACA,YAAIE,WAAW,GAAG,IAAIP,QAAJ,CAAaD,YAAY,CAACM,GAAD,CAAzB,CAAlB,CAHiC,CAKjC;;AACA,YAAIE,WAAW,CAACC,IAAZ,KAAqB,UAAzB,EAAoC;AAChC,eAAKJ,eAAL,GAAuBG,WAAvB;AACH;;AAED,aAAKJ,aAAL,CAAmBM,IAAnB,CAAwBF,WAAxB;AACH;AACJ;AACJ;;AAEDG,EAAAA,kBAAkB,GAAE;AAChB,WAAO,KAAKN,eAAZ;AACH;;AAEDO,EAAAA,eAAe,GAAE;AACb,WAAO,KAAKR,aAAZ;AACH;AAED;;;;;;AAIAS,EAAAA,IAAI,CAACC,SAAD,EAAW;AACX;AACA,QAAI;AACA,UAAIC,eAAe,GAAG,KAAKV,eAAL,CAAqBW,gBAArB,CAAsCF,SAAtC,CAAtB,CADA,CAGA;;AACA,UAAIG,UAAU,GAAG,KAAKb,aAAL,CAAmBc,IAAnB,CACb,UAASC,OAAT,EAAiB;AACb,eAAOA,OAAO,CAACV,IAAR,KAAiBM,eAAxB;AACH,OAHY,CAAjB;;AAMA,UAAIE,UAAU,IAAIG,SAAlB,EAA6B;AACzB,cAAM,sBAAN;AACH,OAFD,MAEK;AACD,aAAKf,eAAL,GAAuBY,UAAvB;AACAI,QAAAA,OAAO,CAACC,GAAR,CAAY,sCAAsC,KAAKjB,eAAL,CAAqBI,IAAvE;AACH;AACJ,KAhBD,CAiBA,OAAOc,GAAP,EAAY;AACRF,MAAAA,OAAO,CAACC,GAAR,CAAY,0CAAZ;AACH;AACJ;AAED;;;;;AAGAE,EAAAA,qBAAqB,GAAE;AACnB,SAAKnB,eAAL,CAAqBoB,gBAArB;AACA;AACH;;AAhEoB","sourcesContent":["import AllLocations from \"./locationdata\"\nimport Location from \"./Location\"\n\nexport default class Map {\n    constructor(){\n        // init empty array\n        this.locationArray = [];\n        this.currentLocation = \"\";\n        for( var key in AllLocations){\n\n            if (AllLocations.hasOwnProperty(key)){\n\n                // construct location object\n                let newLocation = new Location(AllLocations[key])\n\n                // bind Entrance to newLocation\n                if (newLocation.name === \"Entrance\"){\n                    this.currentLocation = newLocation;\n                }\n\n                this.locationArray.push(newLocation);\n            }\n        }\n    }\n\n    getCurrentLocation(){\n        return this.currentLocation;\n    }\n\n    getAllLocations(){\n        return this.locationArray\n    }\n\n    /**\n     * returns the Location after a directino is issued. prints this in console \n     * @param {input direction} direction \n     */\n    move(direction){\n        // find if there is neighbour\n        try {\n            let newLocationName = this.currentLocation.getNeighbourName(direction);\n\n            // find the neighbour and set the current location to this location\n            var findResult = this.locationArray.find(\n                function(element){\n                    return element.name === newLocationName;\n                }\n            );\n\n            if (findResult == undefined ){\n                throw(\"Cannot find location\")\n            }else{\n                this.currentLocation = findResult\n                console.log(\"User moves to this new location: \" + this.currentLocation.name)\n            }\n        }\n        catch (err) {\n            console.log(\"User tries to move to a invalid location\")\n        }\n    }\n\n    /**\n     * logs all accessible neighbours\n     */\n    getAccesiblelocations(){\n        this.currentLocation.getAllNeighbours();\n        return;\n    }\n}"]},"metadata":{},"sourceType":"module"}